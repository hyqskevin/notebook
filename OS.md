## 第一章 引论
### 1.1.发展
  - #### 1.批量操作系统
    - ##### 单道批处理
      - 作业=程序+数据+作业说明书<p>
      - 系统管理员将作业装到输入设备->**监督程序** 控制转存到辅存进行依次调度->作业调入主存进行编译->执行目标代码
      - 自动性，顺序性，单道性
    - ##### 脱机批处理
      - 主机负责计算，卫星机负责I/O
    - ##### 多道程序设计
      - 多道相互独立的程序穿插运行
      - 宏观上并行，微观上串行
      - CPU，内存，I/O设备利用率提高，系统吞吐量提升，但作业平均周转时间较长、无交互能力
  - #### 2.分时操作系统
    - 主机同时允许多个用户使用终端，共享主机中的资源的系统。
    - 多路性，独立性，及时性，交互性
  - #### 3.实时操作系统
    - 再规定时间内处理完毕并作出反应
    - 再多可靠性和安全性

  - 4.个人操作系统
    Dos/Win/Unix、Linux
  - 网络操作系统，分布式系统，嵌入式系统……
### 1.2.基本特征*
  - #### 1.并发(最重要)
    - 并行性：两个或以上事件在同一时刻发生
    - 并发性* ：两个或以上事件在同一时间内间隔发生，即微观上交替执行，宏观上同时运行
  - #### 2.共享：系统中的资源可供内存中多个并发执行的进程共同使用
    - 互斥共享：一段时间内只允许一个进程访问资源(打印机)
    - 同时访问：宏观同时，微观交替(内存，磁盘 )
  - #### 3.虚拟：通过某种技术把一个物理实体变为若干个逻辑上的对应物。(CPU，主存，处理机)
  - #### 4.异步(不确定性)：由于资源的竞争，内存中程序的进程不可知
### 1.3.主要功能
  - OS是计算机系统软硬件资源的管理者
  - #### 四种资源：处理器、存储器、I/O设备及信息。
  - #### 五种功能：
    - 处理器管理：进程的同步、控制、通信；作业和进程调度
    - 存储器管理：内存的分配、保护、扩充及地址映射
    - I/O设备管理：接收用户程序的I/O请求，缓冲管理，分配设备，启动设备
    - 文件资源管理：存储空间的管理，读/写保护
    - 提供接口*：
      - 用户(命令)接口：联机用户接口，脱机用户接口，图形接口
      - 系统调用接口* ：在应用程序和操作系统之间，用户在程序一级请求操作系统服务
        - 系统调用号：每个系统调用分配一个唯一的系统调用号
        - 系统调用表：保存系统调用函数的指针，负责系统调用跳转
        - 流程：在应用程序中运行系统调用——>在库中封装例程——>内核态下执行int 0x80系统调用处理程序ystem_call()——>找到系统调用服务例程——>执行系统调用

### 1.4.结构及硬件支持
  <center>
    <table>
      <tr>
        <th>结构</th>
        <th>概念</th>
        <th>优缺点</th>
        <th>实例</th>
      </tr>
      <tr>
        <th>单体结构</th>
        <th>众多过程集合，过程定义接口，支持互相调用</th>
        <th>高效率|程序结构不清晰，难以维护，错误多</th>
        <th>Unix,Linux</th>
      </tr>
      <tr>
        <th>模块化结构</th>
        <th>模块按功能划分并封装，模块定义接口，支持相互调用</th>
        <th>便于理解和维护，加速开发|模块间依赖关系复杂</th>
        <th></th>
      </tr>
      <tr>
        <th>可扩展结构(微内核)</th>
        <th>基础核心+其它核心，采用面向对象技术，机制和策略分离</th>
        <th>正确、灵活、易维护、可扩充，易移植|运行效率低</th>
        <th>windows</th>
      </tr>
      <tr>
        <th>层次结构</th>
        <th>分为若干个层次，每层又由若干个模块组成，高层仅依赖于紧邻它的低层。</th>
        <th>易扩充和维护|系统效率降低</th>
        <th></th>
      </tr>
    </table>
  </center>

  - #### 微内核结构*
    - 特点
      - 足够小的内核，集成最基本的核心功能,实现和硬件紧密相关的处理，提供基础通信
      - 客户/服务器模式：OS大部分功能由外部用户态中的进程实现，客户与服务器之间借助微内核来实现信息交互
      - 机制与策略分离，通常将机制放在微内核中
      - 采用面向对象技术
    - 功能：与硬件紧密相关的部分放入微内核中|进程(线程)管理，低级存储器管理，中断和陷入处理
    - ##### 优点：提高系统的可扩展性，增强系统的可靠性、可移植性，提供了对分布式系统的支持，融入了面向对象技术
    - 问题：在微内核 OS 中,由于客户和服务器及服务器和服务器之间的通信,都需通过微内核，导致运行效率降低。

### 1.5.处理机特权级
  - 用户态(user mode)/目态：操作系统的管理程序执行时机器所处的状态(特权级)。使用全部指令|使用全部系统资源(包括整个存储区域) 。
  - 系统态(supervisor mode)/管态：用户程序执行时机器所处的状态。禁止使用特权指令|不能直接取用资源与改变机器状态|只允许用户程序访问自己的存储区域。
  - 特权指令集：
    - 涉及外部设备的I/O指令
    - 修改特殊寄存器的指令：CPU状态寄存器PS、段地址寄存器、时钟寄存器、I/O设备控制寄存器等
    - 改变机器状态的指令：停机指令、中断返回指令、禁止中断指令等

### 1.6.中断处理*
  - 指 CPU 暂停执行当前的指令流程,去处理外部设备或硬件的中断信号的过程。
  - 类型：
    - 功能分类：I/O中断，外部中断，程序中断，故障中断，访管中断
    - 来源分类：俘获(内部事件引起，如时钟、磁盘、终端),外中断(外部事件引起，如非法指令、地址越界、浮点溢出、trap指令)
  - 中断屏蔽：CPU可以响应请求，也可以不响应。一般设置两根中断请求输入线：可屏蔽中断请求INTR(Interrupt Require)和不可屏蔽中断请求NMI(NonMaskable Interrupt)。
  - 中断优先级：多个中断同时发生时优先处理高级中断，同级中断任意排序
  - 中断嵌套：在处理低级中断时允许高级中断的发生
  - 中断向量表：以中断ID作为索的表，引是中断/异常处理的重要数据结构，引导CPU转向要处理的程序
  - #### 中断响应* ：CPU发现已有中断请求时，暂停现行程序执行，并自动引出中断处理程序的过程
    - 响应过程：
      - 1.保护现场：中断响应开始时，把现场的信息(当前指令运行情况，下一条指令地址，当前指令执行情况和中间结果等)保存在主存中。
      - 2.执行中断/异常处理程序
      - 3.恢复现场：把之前保留的该程序现场信息从主存中送至相应的寄存器中
    - 硬件：PS，PC存入临时寄存器——>根据中断ID找到中断向量(PSW->PC)，处理程序(入口)——>切换到内核态，存入PS，PC——>执行中断/异常处理程序
    - 软件：

## 第二章 进程
### 2.1.进程概念
  - 前趋图：有向无循环图，描述进程之间执行的前后关系。
  - #### 顺序执行：当前一操作(程序段)执行完后，才能执行后继操作。
    - 特征：顺序性，封闭性，可再现性
  - #### 并发执行：若干个程序段同时在系统中运行，在执行在时间上重叠。
    - 特征：间断性(程序之间有相互制约的关系)，失去封闭性(多个程序共享系统中的资源)，不可在现性(封闭性缺失导致不可再现)
  - #### 进程*：一个可并发程序在一个数据集上运行一次的过程,是系统进行资源分配和调度的一个独立单位
    - 结构：程序段 + 数据段 + PCB(进程控制块)
    - 特征：动态性(进程有一定的生命期)，并发性，独立性，异步性(进程按各自独立的、不可预知的速度向前推进)
    - 基本状态：就绪，运行，阻塞与唤醒，挂起与激活，(创建，终止)
  - #### 进程控制块(PCB)：运行进程时建立的数据结构
    - 内容：进程标识符，处理机状态，进程调度信息(进程状态、优先级、事件等)，进程控制信息(程序和数据的地址、进程同步和通信机制、资源清单、链接指针)
    - 组织方式：链表(就绪、执行、等待、空白)，索引

### 2.2.进程控制
  - 原语：完成一个过程不可分割的基本单位
  - #### 进程创建(create)
    - 流程：申请空白PCB——>为新进程分配资源——>初始化进程控制块——>将新进程插入就绪队列
    - 事件：用户登录，作业调度，提供服务，应用请求
  - #### 进程终止(kill)
    - 检索该进程的PCB并读出状态——>终止进程的进行——>资源归还给父进程或系统——>PCB从队列中移除
    - 事件：正常结束，异常(越界、非法指令、超时、运算出错、I/O故障)，外界干预(操作系统干预、父进程请求、父进程终止)
  - #### 进程阻塞和唤醒(sleep/wakeup)
    - 阻塞事件：请求系统服务，启动某种操作，新数据未到达，无新操作
    - 唤醒事件：阻塞事件结束
  - #### 进程挂起与激活(suspend/active)

### 2.3.进程同步*
  - #### 进程制约
    - 间接制约：资源竞争
      - 临界资源：一次只允许一个进程使用(如打印机)。
      - 互斥：一个进程正在访问目标资源，另一个必须等待
    - 直接制约:进程间有合作，有先后顺序
  - #### 同步机制遵循原则*
    - 1.空闲让进。当无进程处于临界区时，允许进程立即进入临界区
    - 2.忙则等待。当已有进程进入临界区时，其它试图进入临界区的进程必须等待
    - 3.有限等待。要求访问临界资源的进程，应在有限时间内能进入自己的临界区
    - 4.让权等待。当进程不能进入自己的临界区时，应立即释放处理机
    - e.g. (1)算法实现

    ```
      turn = 0; flag[2]
      P0:flag[0]=1;turn=1;while(flag[1]&&turn==1);临界区flag[0]=0;
      P0:flag[1]=1;turn=0;while(flag[0]&&turn==0);临界区flag[1]=0;
      (turn决定P0/P1进入临界区)
    ```
     (2)锁机制实现(clock) 0开1闭<p>
     (3)关中断实现
  - #### 信号量机制*
    - P(s)：不可分的原语操作，对信号量-1，若相减结果为负，则调用P(s)的进程被阻塞
    - V(s)：对信号量+1，若相加结果大于0，进程继续执行
    - 互斥信号一般记为mutex，赋初值为1

    ```
    - typedef struct{
        int value; PCB*L;
      }semaphore *S /*value为非负整数，L为空链表*/
      P(S){ S->value--; if(S->value<0) sleep(S->L);}
      V(S){ S->value++;if(S->value<=0) wakeup(s->L);}
    - 算法实现  
      /*互斥*/
      semaphore mutex=1; /*互斥信号量*/
      cobegin
        P(mutex); critical section(临界区); V(mutex);
      coend
      /*同步*/
      semaphore S1,S2=0; /*同步信号量*/
      cobegin
        p(){P(S1); 前驱工作; V(S2);}
        l(){P(S2); 后继工作; V(S1);}
      coend
    ```
  - #### 经典进程同步问题*
    - 生产者-消费者问题，哲学家进餐问题，读-写问题

### 2.4.进程通信
- 进程通信是指进程之共享消息的一种交互方式，主要介绍以较高的效率传递较多数据的高级进程通信方式。
- #### 1.共享存储器系统通信(Shared-Memory System)：通过共享某些数据结构或共享存储器实现进程之间的信息交换。
  - 通信过程：申请共享存储分区——>将分区映射到本进程地址空间中——>进行数据读写——>释放共享存储分区——>删除共享存储分区
  - 特点：没有中间环节,直接把共享内存映射到不同进程的虚拟地址空间中,进程可直接进行访问,通信直接快速<br>没有进程同步机制
- #### 2.管道(pipe)通信：通过先进先出管道连接一个读进程和一个写进程,以实现它们之间通信
  - 无名管道可实现父子或兄弟进程的通信|有名管道可实现任意进程通信
  - 管道通信机制：进程互斥，进程同步，确认对方是否存在
- #### 3.消息传递系统通信(Message passing System)：进程间的数据交换是以消息(message)为单位实现通信，分为消息头和消息正文
  - 实现类型：消息缓冲队列机制(发送进程——>消息缓冲队列——>接收进程)<br>
  信箱通信(发送进程——>中间信箱——>接收进程)

### 2.5.进程调度*
- 调度和分派：对所有处于就绪状态的进程,按一定的原则选择一个进程准备参与运行;当调度时机来到时,从就绪队列中移出队首进程并赋予其处理机的使用权。(进程——>就绪队列——>执行)
- 进程调度时机：时间片用完|当前进程本身状态(终止，等待)发生转换|从系统调用/中断处理中返回用户态|就绪队列中出现比当前进程优先级更高的进程|进程出错被挂起时
- 处理机调度层次：高级调度(作业调度，长程调度)|低级调度(进程调度，短程调度)|中级调度(提高内存利用率和系统吞吐量)
- #### 进程调度方式
  - 非抢占方式：一旦把处理机分配给某进程后，一直运行，不会因为时钟中断等原因而抢占正在运行进程的处理机，也不允许其它进程抢占已经分配给它的处理机。直至该进程完成，自愿释放处理机，或发生某事件而被阻塞时，才再把处理机分配给其他进程。
  - 抢占方式
    - 优先权原则：对一些重要的和紧急的作业赋予较高的优先权。
    - 短作业(进程)优先原则：当新到达的作业(进程)比正在执行的作业(进程)明显的短时，将暂停当前长作业(进程)的执行，将处理机分配给新到的短作业(进程)，使之优先执行。
    - 时间片原则：各进程按时间片轮流运行，当一个时间片用完后，便停止该进程的执行而重新进行调度。
    - 内核完全不可抢占(winNT,unix)，部分可抢占(Linux)，完全可抢占(win2000，solaris)
- #### 进程调度算法*
    - 1.平均周转时间：$T=\frac1{n}[\sum_{i=1}^{n}T_i]$
    - 2.带权周转时间：$W=\frac1{n}[\sum_{i=1}^{n}\frac{T_i}{T_s}]$
    - 3.先来先服务算法(FCFS)：每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行
    - 4.短作业(进程)优先调度算法(SJ(P)F)
      - 非抢占式|按估计运行时间进行抢占|按剩余运行时间进行抢占
      - 缺点：对长作业不利，未考虑紧迫程度，估计运行时间不准
    - 5.高优先权调度算法
      - 静态优先权：进程创建时确定优先权，整个周期内都不改变
      - 动态优先权：进程创建时赋优先权初值，运行期间调整权值
        - 改变规则：进程使用CPU 超过一定数值时，降低优先级<p>
        进程I/O操作后，增加优先级<p>
        进程等待时间超过一定数值，提高优先级
    - 6.时间片轮转(循环轮转)调度算法
      - 时间片大小确定：Time(响应时间)=N(进程数)q(时间片)，时间片太大会退化为FCFS|太小增加系统开销
      - 当执行的时间片用完，将程序送入就绪队列末尾
    - 7.多级反馈队列调度算法：按优先级设置多个就绪队列和时间片，各级就绪队列按FIFO组织，FCFS调度，具有较好的性能
      - 调度算法设计
        - 进程状态设计：运行|低优先就绪|高优先状态|因I/O等待状态
        - 队列结构设计：低优先|高优先|因I/O等待队列
        - 调度算法：优先调度+时间片调度结合
      - 调度效果：优先照顾I/O和计算量大的进程

### 2.6.线程
- 定义：进程内一个相对独立的可调度的执行单元
- 线程/进程比较
  - 1.调度：线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位
  - 2.并发性：都可并发执行，能有效提高系统利用率和吞吐量
  - 3.拥有资源：线程自己不拥有系统资源，但可以访问其隶属进程的资源
  - 4.系统开销：线程切换代价低于进程，同步和通信实现方面比进程容易
- 属性：独立调度和分派的基本单位|可并发执行|进程资源可共享|有生命周期
- #### 状态：就绪，执行，阻塞，终止
- #### 实现机制：
  - 用户级线程(ULT)：提供应用程序的开发和运行环境
    - 优点：调度切换开销较小|可运行在任何操作系统上|可用算法优化
    - 缺点：线程在被系统调用时会导致所属进程阻塞|同一个进程中两个线程不能同时运行在两个处理器上
  - 内核级线程(KLT)：完全由内核实现
    - 优点：内核可以调用统一进程的多个线程|阻塞在线程一级完成|核心栈是多线程的   ？？？
    - 缺点：统一进程内线程的切换系统调用开销较大
  - ULT&KLT连接
    - 一对一模型：并行能力强，每创建一个用户线程相应地就需要创建一个内核线程，开销较大，要限制线程数
    - 多对一模型：线程管理的开销小，效率高，但当一个线程在访问内核时发生阻塞，则整个进程都会被阻塞，而且在多处理机系统中，一个进程的多个线程无法实现并行
    - 多对多模型：结合两个模型的特点
