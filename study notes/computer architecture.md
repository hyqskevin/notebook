## 第一章 概念
  - #### 1.1发展
    <center>
      <table>
        <tr>
          <th>时间</th>
          <th>发展</th>
          <th>速度</th>
        </tr>
        <tr>
          <th>1946之后的25年</th>
          <th>计算机制造技术发展，计算机系统结构创新</th>
          <th>提高25%</th>
        </tr>
        <tr>
          <th>20世纪70年代末和80年代初</th>
          <th>大规模集成电路，微处理器</th>
          <th>35%</th>
        </tr>
        <tr>
          <th>80年代中期后16年</th>
          <th>RISC</th>
          <th>50%</th>
        </tr>
        <tr>
          <th>2002年后</th>
          <th>功耗问题，可开发并行指令减少，存储器访问缓慢，</th>
          <th>降到20%</th>
        </tr>
        <tr>
          <th>2014年后</th>
          <th>多核处理，指令级并行转向线程级数据级并行</th>
          <th>/</th>
        </tr>
      </table>
    </center>

  - #### 1.2层次结构
   <center>翻译方法实现</center>

    ->L6：应用语言虚拟机
    ->L5：高级语言虚拟机
    ->L4:汇编语言虚拟机

   <center>解释方法实现</center>

    ->L3:操作系统虚拟机：传统机器级指令+操作系统级指令
    ->L2:机器语言(传统机器级)：RISC无L1，L2直接采用硬件逻辑，速度快
    ->L1:微程序机器级：微指令集
   低层计算机属性对高层计算机的程序员是透明的<p>
   计算机结构/组成/实现<p>
   计算机系统结构Flynn分类：SISD,SIMD,MISD,MIMD

  - #### 1.3定量分析技术
    - ##### 计算机系统设计定量原理
      - 以经常性事件为重点
      - Amdahl定律*
        <center>

          $系统加速比=\frac{系统性能_{改进后}}{系统性能_{改进前}}=\frac{总时间_{改进前}}{总时间_{改进后}}=\frac1{(1-改进比例)+\frac{改进比例}{部件加速比}}$
        </center>
      - cpu性能公式*
        <center>
        CPU时间 = IC × CPI × 时钟周期时间
        </center>
    - ##### 计算机系统性能评测
      - $n=\frac{执行时间_Y}{执行时间_X}=\frac{性能_X}{性能_Y}$ 执行时间和性能成反比
      - 基准测试程序(benchmark)
      <p/>

  - 1.4计算机结构的发展
    - 冯诺依曼结构
  - 1.5 并行 指令内部并行——>指令集并行——>线程级并行——>任务级或过程级并行——>作业或程序并行
    - 措施：时间重叠，资源重复，资源共享

## 第二章 指令集结构
#### 2.1分类
  <center>
    <table>
      <tr>
        <th>堆栈结构</th>
        <th>累加器结构</th>
        <th>寄存器-存储器结构(RM)</th>
        <th>寄存器-寄存器结构(RR)</th>
      </tr>
      <tr>
        <th>操作数都为隐式，位于栈顶/次栈顶</th>
        <th>操作数累加器为隐式，存储器单元显式</th>
        <th>显式，位于寄存器/存储器</th>
        <th>显式，都位于寄存器</th>
      </tr>
      <tr>
        <th>结果写入栈顶</th>
        <th>结果送回累加器</th>
        <th>结果写入通用寄存器组</th>
        <th>结果写入通用寄存器组</th>
      </tr>
      <tr>
        <th>程序占用空间小|堆栈无法随机访问</th>
        <th>占用空间小|会频繁访问存储器</th>
        <th>访问速度快，容易编译，代码紧凑|操作数不对称，时钟周期不同</th>
        <th>访问速度快，容易编译，代码简洁，时钟周期相近|指令条数多，耗内存</th>
      </tr>
      <tr>
        <th>push A</th>
        <th>load A</th>
        <th>load R1,A</th>
        <th>load R1,A</th>
      </tr>
      <tr>
        <th>push B</th>
        <th>add B</th>
        <th>add R1,B</th>
        <th>add R2,B</th>
      </tr>
      <tr>
        <th>add</th>
        <th>store C</th>
        <th>store R1,C</th>
        <th>add R3,R1,R2</th>
      </tr>
      <tr>
        <th>pop C</th>
        <th></th>
        <th></th>
        <th>store R3,C</th>
      </tr>
    </table>
  </center>

#### 2.2寻址方式(部分)
  - 立即数寻址：Regs[R]<——Regs[R]+num<p>
  - 直接寻址：Regs[R]<——Regs[R]+Mem[num]<p>
  - 寄存器寻址：Regs[R1]<——Regs[R1]+Regs[R2]<p>
  - 寄存器间接寻址：Regs[R2]<——Regs[R2]+Mem[Regs[R1]]<p>
  - 偏移寻址：Regs[R2]<——Regs[R2]+Mem[Regs[R1]+num]<p>
  - 存储器间接寻址：Regs[R2]<——Regs[R2]+Mem[Mem[Regs[R1]]]<p>
  - 索引寻址：Regs[R3]<——Regs[R3]+Mem[Regs[R1]+Regs[R2]]<p>

#### 2.3功能设计
  - 指令级基本要求：完整性(指令足够用)，规整性(对称性，均匀性)，高效率(指令执行速度快，使用频度高)，兼容性
  - CISC
    - 面向目标程序的增强指令：增强运算型指令，数据传送指令，程序控制指令|三方面会增加硬件成本和复杂度
    - 面向高级语言的优化：增强对高级语言和编译器的支持，使高级语言成为计算机的机器语言
    - 面向操作系统的优化：指令级支持操作系统进程的管理和切换，存储管理，信息保护，进程同步与互斥
    - 存在问题：许多指令很少用|指令级庞大，条数多，指令功能复杂，占用大量芯片面积容易造成错误|CPI值较大，执行速度慢|不易采用流水线技术提升性能
  - RISC原则：指令条数少且简单|采用简单而统一的指令格式，并减少寻址方式|指令执行在单个周期内完成|采用load-host结构，除load和host可访问存储器，其他指令都在寄存器间进行|指令采用硬件逻辑实现|优化编辑器|利用流水线技术提升性能

## 第三章 流水线技术
#### 3.1 概念
- 将每个子过程和部件称为流水线的级或段，把段连接起来形成了流水线；流水线的段数称为深度。
- 流水线的执行过程：取指令，译码，执行，存结果
- 流水线的执行过程采用时空图描述
- 流水线特点
  - 流水线把一个处理过程分解为若干子过程，每个子过程由专门的部件实现，过程间并行工作以缩短时间
  - 流水线各段的时间应该尽可能相等，否则会形成瓶颈
  - 流水线每个功能部件后面需要一个缓冲寄存器(锁存器)传送相邻间的数据，并隔离各段的处理工作
  - 流水线技术适合于大量重复的时序过程
  - 流水线技术需要通过时间和排空时间
- 流水线的分类
  - 单功能|多功能，静态流|动态，部件级|处理机级|处理机间，线性|非线性，顺序|乱序

#### 3.2 性能指标*
- 吞吐率：$TP = \frac{n}{T_k}$
  - 各段时间相等流水线：$TP = \frac{n}{(k+n-1)\Delta t}$<p>
    $TP_{max} = lim \frac{n}{(k+n-1)\Delta t} = \frac1{\Delta t}$ | $TP = \frac{n}{k+n-1}TP_{max}$ (当 n>>k 时 $TP \approx TP_{max}$)
  - 各段时间不相等流水线：$TP = \frac{n}{\sum_{i=1}^k \Delta t_i+(n-1)max(\Delta t_1,\Delta t_2...,\Delta t_k)}$<p>
    $TP_{max} = \frac1{max(\Delta t_1,\Delta t_2...,\Delta t_k)}$
  - 解决瓶颈问题：细分瓶颈段，使各段时间相等|重复设置瓶颈段并行工作(控制逻辑复杂，硬件成本高)
- 加速比：$S = \frac{T_s}{T_k}$
  - 各段相等：$S = \frac{nk}{k+n-1}$
  - 各段不相等：$S = \frac{n\sum_{i=1}^k \Delta t_i}{\sum_{i=1}^k \Delta t_i+(n-1)max(\Delta t_1,\Delta t_2...,\Delta t_k)}$
- 效率:$E = TP·\Delta t$ | $E = \frac{S}{k}$
  - 各段相等：$E = \frac{n}{k+n-1}$
  - 各段不相等：$E = \frac{n\sum_{i=1}^k \Delta t_i}{k[\sum_{i=1}^k \Delta t_i+(n-1)max(\Delta t_1,\Delta t_2...,\Delta t_k)]}$

#### 3.3 流水线的相关和冲突
- 五段流水线
- 流水线相关
  - 数据相关
  - 名相关
    - 反相关
    - 输出相关
    - 换名技术
  - 控制相关
- 流水线冲突
  - 结构冲突
    - 增加停顿周期(气泡)
  - 数据冲突
    - 写后读冲突
    - 写后写冲突
    - 读后写冲突
    - 定向(旁路)技术：
    - 互锁机制：
    - 指令/流水线调度技术：
  - 控制冲突

## 第四章 指令集并行

## 第五章 存储系统
#### 5.1 存储结构
#### 5.2 Cache
- 基本结构
- 映像规则
- 查找
- Cache替换算法
- 写策略
- Cache性能分析

#### 5.3 降低Cache不命中率
- 不命中类型
  - 强制性不命中(Compulsory miss)：第一次访问块时不在Cache中，需从下一级调入Cache。| 强制性不命中率很小，不受Cache容量和关联度影响
  - 容量不命中(Capacity miss)：程序执行所需的块不能全部调入Cache中，某些块替换后再重新访问会出现不命中。| 容量不命中随容量增加而减少，不受关联度影响
  - 冲突不命中(Conflict miss)：碰撞不命中/干扰不命中  在直接映像或组相联Cache中，太多块被分到同一组中，当某个块被替换后再重新访问会出现不命中。| 相联度越高，冲突不命中率就越少
- 1.增加Cache块大小：不命中率先减后增，减少强制性不命中的同时会增加冲突不命中
- 2.增加Cache容量：会增加成本和命中时间，在片外Cacheh中用的比较多
- 3.提高相联度：>8的相联度实际意义不大，会增加命中时间
- 4.伪相联：将Cache分成两部分，以直接映像方式访问第一个部分，若不命中，检查另一个相对应的位置，若匹配，则发生了伪命中，是正常命中时间的2、3倍。| 但多种命中时间会增加流水线的复杂程度，会用在离处理机较远的Cache中
- 5.硬件预取：指令和数据在处理器访问之前就进行预取，预取内容放入Cache或外部缓冲器中。| 会影响正常不命中的处理
- 6.编译器控制预取：编译器在程序中加入预取指令实现提前存取，使执行指令和读取数据能重叠进行
- 7.编译优化：对软件进行优化来降低不命中率
- 8.牺牲Cache

#### 5.4 减少Cache不命中开销
- 1.采用两级Cache*：Cache1小而块，Cache2容量大
  - $平均访存时间 = 命中时间_{l1}+不命中率_{l1} * (命中时间_{l2}+不命中率_{l2} * 不命中开销_{l2})$
  - $平均访存停顿时间 = 平均访存时间 - 命中时间_{l1}$
  - $局部不命中率 =\frac{Cache不命中次数}{Cache访存次数}$
  - $全局不命中率 = \frac{Cache不命中次数}{CPU总访存次数}$
  - $全局不命中率_{l2} = 不命中率_{l1} * 不命中率_{l2}$
- 2.读不命中优先于写
- 3.写缓冲合并
- 4.请求字处理技术
- 5.非阻塞Cache技术

#### 5.5 减少命中时间
#### 5.6 并行主存系统
#### 5.7 虚拟存储器
