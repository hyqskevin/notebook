## <center>第一章 引论</center>
### 1.1.发展
  - #### 1.批量操作系统
    - 单道批处理
      - 作业=程序+数据+作业说明书<p>
      - 系统管理员将作业装到输入设备->**监督程序** 控制转存到辅存进行依次调度->作业调入主存进行编译->执行目标代码
      - 自动性，顺序性，单道性
    - 脱机批处理：主机负责计算，卫星机负责I/O
    - 多道程序设计
      - 多道相互独立的程序穿插运行
      - 宏观上并行，微观上串行
      - CPU，内存，I/O设备利用率提高，系统吞吐量提升，但作业平均周转时间较长、无交互能力
  - #### 2.分时操作系统
    - 主机同时允许多个用户使用终端，共享主机中的资源的系统。
    - 多路性，独立性，及时性，交互性
  - #### 3.实时操作系统
    - 再规定时间内处理完毕并作出反应
    - 再多可靠性和安全性
    <p>

    - 4.个人操作系统
      Dos/Win/Unix、Linux
    - 网络操作系统，分布式系统，嵌入式系统……
### 1.2.基本特征*
  - 1.并发(最重要)
    - 并行性：两个或以上事件在同一时刻发生
    - 并发性* ：两个或以上事件在同一时间内间隔发生，即微观上交替执行，宏观上同时运行
  - 2.共享：系统中的资源可供内存中多个并发执行的进程共同使用
    - 互斥共享：一段时间内只允许一个进程访问资源(打印机)
    - 同时访问：宏观同时，微观交替(内存，磁盘 )
  - 3.虚拟：通过某种技术把一个物理实体变为若干个逻辑上的对应物。(CPU，主存，处理机)
  - 4.异步(不确定性)：由于资源的竞争，内存中程序的进程不可知
### 1.3.主要功能
  - OS是计算机系统软硬件资源的管理者
  - #### 四种资源：处理器、存储器、I/O设备及信息。
  - #### 五种功能：
    - 处理器管理：进程的同步、控制、通信；作业和进程调度
    - 存储器管理：内存的分配、保护、扩充及地址映射
    - I/O设备管理：接收用户程序的I/O请求，缓冲管理，分配设备，启动设备
    - 文件资源管理：存储空间的管理，读/写保护
    - 提供接口*：
      - 用户(命令)接口：联机用户接口，脱机用户接口，图形接口
      - 系统调用接口* ：在应用程序和操作系统之间，用户在程序一级请求操作系统服务
        - 系统调用号：每个系统调用分配一个唯一的系统调用号
        - 系统调用表：保存系统调用函数的指针，负责系统调用跳转
        - 流程：在应用程序中运行系统调用——>在库中封装例程——>内核态下执行int 0x80系统调用处理程序ystem_call()——>找到系统调用服务例程——>执行系统调用
### 1.4.结构及硬件支持
  <center>
    <table>
      <tr>
        <th>结构</th>
        <th>概念</th>
        <th>优缺点</th>
        <th>实例</th>
      </tr>
      <tr>
        <th>单体结构</th>
        <th>众多过程集合，过程定义接口，支持互相调用</th>
        <th>高效率|程序结构不清晰，难以维护，错误多</th>
        <th>Unix,Linux</th>
      </tr>
      <tr>
        <th>模块化结构</th>
        <th>模块按功能划分并封装，模块定义接口，支持相互调用</th>
        <th>便于理解和维护，加速开发|模块间依赖关系复杂</th>
        <th></th>
      </tr>
      <tr>
        <th>可扩展结构(微内核)</th>
        <th>基础核心+其它核心，采用面向对象技术，机制和策略分离</th>
        <th>正确、灵活、易维护、可扩充，易移植|运行效率低</th>
        <th>windows</th>
      </tr>
      <tr>
        <th>层次结构</th>
        <th>分为若干个层次，每层又由若干个模块组成，高层仅依赖于紧邻它的低层。</th>
        <th>易扩充和维护|系统效率降低</th>
        <th></th>
      </tr>
    </table>
  </center>

  #### 微内核结构*
  - 1.特点
    - 足够小的内核，集成最基本的核心功能,实现和硬件紧密相关的处理，提供基础通信
    - 客户/服务器模式：OS大部分功能由外部用户态中的进程实现，客户与服务器之间借助微内核来实现信息交互
    - 机制与策略分离，通常将机制放在微内核中
    - 采用面向对象技术
  - 2.功能：与硬件紧密相关的部分放入微内核中|进程(线程)管理，低级存储器管理，中断和陷入处理
    - 优点：提高系统的可扩展性，增强系统的可靠性、可移植性，提供了对分布式系统的支持，融入了面向对象技术
  - 3.问题：在微内核 OS 中,由于客户和服务器及服务器和服务器之间的通信,都需通过微内核，导致运行效率降低。
### 1.5.处理机特权级
  - 用户态(user mode)/目态：操作系统的管理程序执行时机器所处的状态(特权级)。使用全部指令|使用全部系统资源(包括整个存储区域) 。
  - 系统态(supervisor mode)/管态：用户程序执行时机器所处的状态。禁止使用特权指令|不能直接取用资源与改变机器状态|只允许用户程序访问自己的存储区域。
  - 特权指令集：
    - 涉及外部设备的I/O指令
    - 修改特殊寄存器的指令：CPU状态寄存器PS、段地址寄存器、时钟寄存器、I/O设备控制寄存器等
    - 改变机器状态的指令：停机指令、中断返回指令、禁止中断指令等
### 1.6.中断处理*
  - 指 CPU 暂停执行当前的指令流程,去处理外部设备或硬件的中断信号的过程。
  - 类型：
    - 功能分类：I/O中断，外部中断，程序中断，故障中断，访管中断
    - 来源分类：俘获(内部事件引起，如时钟、磁盘、终端),外中断(外部事件引起，如非法指令、地址越界、浮点溢出、trap指令)
  - 中断屏蔽：CPU可以响应请求，也可以不响应。一般设置两根中断请求输入线：可屏蔽中断请求INTR(Interrupt Require)和不可屏蔽中断请求NMI(NonMaskable Interrupt)。
  - 中断优先级：多个中断同时发生时优先处理高级中断，同级中断任意排序
  - 中断嵌套：在处理低级中断时允许高级中断的发生
  - 中断向量表：以中断ID作为索的表，引是中断/异常处理的重要数据结构，引导CPU转向要处理的程序
  - #### 中断响应* ：CPU发现已有中断请求时，暂停现行程序执行，并自动引出中断处理程序的过程
    - 响应过程：
      - 1.保护现场：中断响应开始时，把现场的信息(当前指令运行情况，下一条指令地址，当前指令执行情况和中间结果等)保存在主存中。
      - 2.执行中断/异常处理程序
      - 3.恢复现场：把之前保留的该程序现场信息从主存中送至相应的寄存器中
    - 硬件：PS，PC存入临时寄存器——>根据中断ID找到中断向量(PSW->PC)，处理程序(入口)——>切换到内核态，存入PS，PC——>执行中断/异常处理程序
    - 软件：
---
## <center>第二章 进程</center>
### 2.1.进程概念
  - 前趋图：有向无循环图，描述进程之间执行的前后关系。
  - #### 顺序执行：当前一操作(程序段)执行完后，才能执行后继操作。
    - 特征：顺序性，封闭性，可再现性
  - #### 并发执行：若干个程序段同时在系统中运行，在执行在时间上重叠。
    - 特征：间断性(程序之间有相互制约的关系)，失去封闭性(多个程序共享系统中的资源)，不可在现性(封闭性缺失导致不可再现)
  - #### 进程*：一个可并发程序在一个数据集上运行一次的过程,是系统进行资源分配和调度的一个独立单位
    - 结构：程序段 + 数据段 + PCB(进程控制块)
    - 特征：动态性(进程有一定的生命期)，并发性，独立性，异步性(进程按各自独立的、不可预知的速度向前推进)
    - 基本状态：就绪，运行，阻塞与唤醒，挂起与激活，(创建，终止)
  - #### 进程控制块(PCB)：运行进程时建立的数据结构
    - 内容：进程标识符，处理机状态，进程调度信息(进程状态、优先级、事件等)，进程控制信息(程序和数据的地址、进程同步和通信机制、资源清单、链接指针)
    - 组织方式：链表(就绪、执行、等待、空白)，索引
### 2.2.进程控制
  - 原语：完成一个过程不可分割的基本单位
  - 1.进程创建(create)
    - 流程：申请空白PCB——>为新进程分配资源——>初始化进程控制块——>将新进程插入就绪队列
    - 事件：用户登录，作业调度，提供服务，应用请求
  - 2.进程终止(kill)
    - 检索该进程的PCB并读出状态——>终止进程的进行——>资源归还给父进程或系统——>PCB从队列中移除
    - 事件：正常结束，异常(越界、非法指令、超时、运算出错、I/O故障)，外界干预(操作系统干预、父进程请求、父进程终止)
  - 3.进程阻塞和唤醒(sleep/wakeup)
    - 阻塞事件：请求系统服务，启动某种操作，新数据未到达，无新操作
    - 唤醒事件：阻塞事件结束
  - 4.进程挂起与激活(suspend/active)
### 2.3.进程同步*
  - #### 进程制约
    - 间接制约：资源竞争
      - 临界资源：一次只允许一个进程使用(如打印机)。
      - 互斥：一个进程正在访问目标资源，另一个必须等待
    - 直接制约:进程间有合作，有先后顺序
  - #### 同步机制遵循原则*
    - 1.空闲让进。当无进程处于临界区时，允许进程立即进入临界区
    - 2.忙则等待。当已有进程进入临界区时，其它试图进入临界区的进程必须等待
    - 3.有限等待。要求访问临界资源的进程，应在有限时间内能进入自己的临界区
    - 4.让权等待。当进程不能进入自己的临界区时，应立即释放处理机
    - e.g. (1)算法实现
    ```
      turn = 0; flag[2]
      P0:flag[0]=1;turn=1;while(flag[1]&&turn==1);临界区flag[0]=0;
      P0:flag[1]=1;turn=0;while(flag[0]&&turn==0);临界区flag[1]=0;
      (turn决定P0/P1进入临界区)
    ```
      (2)锁机制实现(clock) 0开1闭
      (3)关中断实现
  - #### 信号量机制*
    - P(s)：不可分的原语操作，对信号量-1，若相减结果为负，则调用P(s)的进程被阻塞
    - V(s)：对信号量+1，若相加结果大于0，进程继续执行
    - 互斥信号一般记为mutex，赋初值为1
    ```
    - typedef struct{
        int value; PCB*L;
      }semaphore *S /*value为非负整数，L为空链表*/
      P(S){ S->value--; if(S->value<0) sleep(S->L);}
      V(S){ S->value++;if(S->value<=0) wakeup(s->L);}
    - 算法实现  
      /*互斥*/
      semaphore mutex=1; /*互斥信号量*/
      cobegin
        P(mutex); critical section(临界区); V(mutex);
      coend
      /*同步*/
      semaphore S1,S2=0; /*同步信号量*/
      cobegin
        p(){P(S1); 前驱工作; V(S2);}
        l(){P(S2); 后继工作; V(S1);}
      coend
    ```
  - #### 经典进程同步问题*(见书本)
    - 生产者-消费者问题，哲学家进餐问题，读-写问题
### 2.4.进程通信
  - 进程通信是指进程之共享消息的一种交互方式，主要介绍以较高的效率传递较多数据的高级进程通信方式。
  - 1.共享存储器系统通信(Shared-Memory System)：通过共享某些数据结构或共享存储器实现进程之间的信息交换。
    - 通信过程：申请共享存储分区——>将分区映射到本进程地址空间中——>进行数据读写——>释放共享存储分区——>删除共享存储分区
    - 特点：没有中间环节,直接把共享内存映射到不同进程的虚拟地址空间中,进程可直接进行访问,通信直接快速<br>没有进程同步机制
  - 2.管道(pipe)通信：通过先进先出管道连接一个读进程和一个写进程,以实现它们之间通信
    - 无名管道可实现父子或兄弟进程的通信|有名管道可实现任意进程通信
    - 管道通信机制：进程互斥，进程同步，确认对方是否存在
  - 3.消息传递系统通信(Message passing System)：进程间的数据交换是以消息(message)为单位实现通信，分为消息头和消息正文
    - 实现类型：消息缓冲队列机制(发送进程——>消息缓冲队列——>接收进程)
    信箱通信(发送进程——>中间信箱——>接收进程)
### 2.5.进程调度*
  - 调度和分派：对所有处于就绪状态的进程,按一定的原则选择一个进程准备参与运行;当调度时机来到时,从就绪队列中移出队首进程并赋予其处理机的使用权。(进程——>就绪队列——>执行)
  - 进程调度时机：时间片用完|当前进程本身状态(终止，等待)发生转换|从系统调用/中断处理中返回用户态|就绪队列中出现比当前进程优先级更高的进程|进程出错被挂起时
  - 处理机调度层次：高级调度(作业调度，长程调度)|低级调度(进程调度，短程调度)|中级调度(提高内存利用率和系统吞吐量)
  - #### 进程调度方式
    - 非抢占方式：一旦把处理机分配给某进程后，一直运行，不会因为时钟中断等原因而抢占正在运行进程的处理机，也不允许其它进程抢占已经分配给它的处理机。直至该进程完成，自愿释放处理机，或发生某事件而被阻塞时，才再把处理机分配给其他进程。
    - 抢占方式
      - 优先权原则：对一些重要的和紧急的作业赋予较高的优先权。
      - 短作业(进程)优先原则：当新到达的作业(进程)比正在执行的作业(进程)明显的短时，将暂停当前长作业(进程)的执行，将处理机分配给新到的短作业(进程)，使之优先执行。
      - 时间片原则：各进程按时间片轮流运行，当一个时间片用完后，便停止该进程的执行而重新进行调度。
      - 内核完全不可抢占(winNT,unix)，部分可抢占(Linux)，完全可抢占(win2000，solaris)
  - #### 进程调度算法*
    - 1.平均周转时间：$T=\frac1{n}[\sum_{i=1}^{n}T_i]$
    - 2.带权周转时间：$W=\frac1{n}[\sum_{i=1}^{n}\frac{T_i}{T_s}]$
    - 3.先来先服务算法(FCFS)：每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行
    - 4.短作业(进程)优先调度算法(SJ(P)F)
      - 非抢占式|按估计运行时间进行抢占|按剩余运行时间进行抢占
      - 缺点：对长作业不利，未考虑紧迫程度，估计运行时间不准
    - 5.高优先权调度算法
      - 静态优先权：进程创建时确定优先权，整个周期内都不改变
      - 动态优先权：进程创建时赋优先权初值，运行期间调整权值
        - 改变规则：进程使用CPU 超过一定数值时，降低优先级
        进程I/O操作后，增加优先级
        进程等待时间超过一定数值，提高优先级
    - 6.时间片轮转(循环轮转)调度算法
      - 时间片大小确定：Time(响应时间)=N(进程数)q(时间片)，时间片太大会退化为FCFS|太小增加系统开销
      - 当执行的时间片用完，将程序送入就绪队列末尾
    - 7.多级反馈队列调度算法：按优先级设置多个就绪队列和时间片，各级就绪队列按FIFO组织，FCFS调度，具有较好的性能
      - 调度算法设计
        - 进程状态设计：运行|低优先就绪|高优先状态|因I/O等待状态
        - 队列结构设计：低优先|高优先|因I/O等待队列
        - 调度算法：优先调度+时间片调度结合
      - 调度效果：优先照顾I/O和计算量大的进程
### 2.6.线程
  - 定义：进程内一个相对独立的可调度的执行单元
  - 线程/进程比较
    1.调度：线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位
    2.并发性：都可并发执行，能有效提高系统利用率和吞吐量
    3.拥有资源：线程自己不拥有系统资源，但可以访问其隶属进程的资源
    4.系统开销：线程切换代价低于进程，同步和通信实现方面比进程容易
  - 属性：独立调度和分派的基本单位|可并发执行|进程资源可共享|有生命周期
  #### 状态：就绪，执行，阻塞，终止
  #### 实现机制：
  - 用户级线程(ULT)：提供应用程序的开发和运行环境
    - 优点：调度切换开销较小|可运行在任何操作系统上|可用算法优化
    - 缺点：线程在被系统调用时会导致所属进程阻塞|同一个进程中两个线程不能同时运行在两个处理器上
  - 内核级线程(KLT)：完全由内核实现
    - 优点：内核可以调用统一进程的多个线程|阻塞在线程一级完成|核心栈是多线程的   ？？？
    - 缺点：统一进程内线程的切换系统调用开销较大
  - ULT&KLT连接
    - 一对一模型：并行能力强，每创建一个用户线程相应地就需要创建一个内核线程，开销较大，要限制线程数
    - 多对一模型：线程管理的开销小，效率高，但当一个线程在访问内核时发生阻塞，则整个进程都会被阻塞，而且在多处理机系统中，一个进程的多个线程无法实现并行
    - 多对多模型：结合两个模型的特点
---
## <center>第三章 资源分配与死锁</center>
### 3.1 资源管理
### 3.2 资源管理的机制和策略
  - #### 资源分配的机制
    - 资源描述器(rd)：描述各类资源的最小分配单位的数据结构
    - 资源信息块(rib)：描述某类资源的请求者、可用资源和该类资源分配程序等必要信息的数据结构
  - #### 资源分配的策略
    - 先请求先服务：每一个新产生的请求均排在队尾，当资源可用时，取队首元素
    - 优先调度策略：对每一个进程指定一个优先级，每一个新产生的请求，按其优先级的高低插到相应的位置，当资源可用时，取队首元素
  - #### 磁盘调度*
    - 盘面号(磁头号 M)，柱面号(磁道号 L)，扇区号(N)
      - 扇区号包括标识符字段，校验字段，数据字段
    - 存储容量 = 磁头数 x 磁道数 x 每道扇区数 x 每个扇区字节数
    - 编址方式
      - CHS(绝对扇区)
      - LBA(相对扇区) = (i * M * N)+(j * N) + k - 1   //柱面i，磁头j，扇区k
      - 柱面号：i=int(LBA / (M * N))
      - 磁头号：j=[LBA mod(M * N)] / N
      - 扇区号：k=[LBA mod(M * N)] mod N + 1
    - 磁盘访问时间：$T_a = T_s + T_r + T-t$ <p> (寻道时间：$T_s = M * N + s$，旋转延迟时间：$T_r = \frac1{2r}$，传输时间：$T_t = \frac{b}{rN}$)
    - 调度方式
      - 移臂调度：当同时有多条磁道访问请求时，确定磁道访问顺序，以减少平均寻道时间
      - 旋转调度：当一条磁道上有多个扇区访问请求时，确定扇区访问顺序，以减少旋转延迟时间
    - 调度算法*
      - 1.先来先服务(FCFS)
      - 2.最短寻道时间优先(SSTF)：平均寻道距离不是最短，会产生饥饿现象，影响磁盘寿命
      - 3.扫描(SCAN)：电梯算法，以磁头当前移动方向为准
      - 4.N-Step-SCAN：将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次处理这些子队列； 而每处理一个子队列时又采用SCAN算法
      - 5.FSCAN：只将磁盘请求队列分成两个子队列，当前队列按SCAN算法，新的I/O请求放入另一个等待队列
      - 旋转调度算法：当同一磁道（柱面）上有多个扇区请求时，总是选取与当前读写头最近的那个I/O请求，使旋转圈数最少
### 3.3 死锁
### 3.4 死锁处理办法
  - #### 1.预防死锁
    - 静态预防：在作业调度时为选中的作业分配它所需要的所有资源，当资源一旦分配给该作业后，在其整个运行期间这些资源为它独占。<p>
    缺点是资源利用率低，进程运行可能被推迟
    - 动态预防：将所有的系统资源按类型进行线性排队，并赋予不同的序号，所有进程对资源的请求应严格按资源序号递增顺序提出<p>
    优点：系统利用率高，吞吐量大|缺点：限制了新设备的增加，会出现使用的资源顺序与系统规定的顺序不同的情况，造成资源浪费
  - #### 2.避免死锁
    - 系统安全状态：系统能按某种进程顺序，来为每个进程分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺利完成；如果系统无法找到这样一个安全序列，则称系统处于不安全状态。
    - 银行家算法*
      - 可利用资源向量Available[m]，最大需求矩阵Max[1..n,1..m]，分配矩阵Allocation[1..n,1..m]，需求矩阵Need[1..n,1..m]，请求向量Request.
      - Need[i,j] = Max[i,j] - Allocation[i,j]

      - 算法描述
      ---
      1. 若Request[i]≤Need[i],转2；否则错误
      2. 若Request[i]≤Available，转3；否则，表示尚无足够资源，$P_i$须等待
      3. 系统尝试把资源分配给进程$P_i$，并修改以下数据结构：
        Available = Available - Request[i];
        Allocation[i] = Allocation[i] + Request[i];
        Need[i] = Need[i] - Request[i];
      4. 检查资源分配后，系统是否处于安全状态
      5. 设置工作向量Work，结束向量Finish
      6. Finish［i］=false || Need［i,j］≤Work［j］，满足一条，转7
      7. 执行进程$P_i$,完成后释放资源
        Work［j］= Work［j］+ Allocation［i,j]
        Finish［i］= true
        go to step 6;
      8. 如果所有进程的Finish［i］=true都满足，则表示系统处于安全状态
      ---
  - #### 3.检测死锁
    - 资源分配图法：如果资源分配图能完全简化，则系统中没有死锁；否则系统存在死锁
      - 过程：在资源分配图中，找出一个既不阻塞又非独立的进程节点P<p>
              去掉P的所有边，使其成为一个独立节点<p>
              循环上述两个步骤，若所有节点都独立，系统无死锁
    - 检测时机：资源进行请求时|周期性检测|根据CPU使用效率检测
  - #### 4.解除死锁：剥夺资源(挂起，激活机制)|撤销进程
---
## <center>第四章 文件系统</center>
### 4.1 概述
  - #### 文件：逻辑上具有完整意义的信息集合，它有一个名字以供标识，文件名是以字母开头的字母数字串
    - 用途分类：系统文件，库文件，用户文件……
    - 数据形式分类：源文件，目标文件，可执行文件……
    - 保护方式分类：只读，只写，只执行……
    - 内容分类：普通，目录，特殊(FIFO，字符设备，块设备，符号链接)
  - #### 文件系统：文件和对文件进行操纵和管理的软件集合及相关数据结构
    - 功能：按名存取，构造文件结构，提供文件共享，提供存取方法，提供文件保护……
    - 接口：命令接口(终端)，程序接口(系统调用)
### 4.2 文件结构及存储分配
  - #### 逻辑结构：用户对文件进行组织的结构
    - 记录方式：按信息在逻辑上的独立含义来划分
    - 结构类型
      - 有结构文件(记录式)：若干连续顺序的记录构成的文件，如数据库
      - 无结构文件(流式)：文件内信息不再划分单位，由依次的一串字符流构成的文件，以字节为单位，用指针指向下一个访问的字符
      - **UNIX，DOS，Windows系统都为流式文件**
    - 存取方式：顺序存取(磁带)，随机存取(read/write)
  - #### 物理结构：文件在物理存储器中的存储方式
    - 记录方式：在存储介质上由连续信息所组成的一个区域(块)
    - 1.连续文件：将逻辑文件中的信息顺序存储到连续的物理盘块中
      - 文件目录：文件名|起始块|块数
      - 优缺点：顺序访问容易，速度快，查找快，可随机存取|磁盘会产生外部碎片，需要事先知道文件长度，文件修改困难
    - 2.串联文件：离散分配空间，通过链接指针索引
      - 2.1隐式链接：在文件目录的每个目录项中，都须含有指向链接文件第一个盘块和最后一个盘块的指针
        - 只适合顺序访问和存取，文件容易丢失
        - 为了提高检索速度和减小指针所占用的存储空间，可以将几个盘块组成一个簇
      - 2.2显式链接：把用于链接文件各物理块的指针，显式地存放在内存的一张链接表中，以物理盘块号为序，表项内容为指向某文件的下一盘块的指针
      - 优缺点：存储空间利用率高，扩充和修改容易|顺序存取效率高但随机存取效率低
    - 3.FAT，NTFS技术
      - 文件结构：引导区|FAT1|FAT2|根目录区|数据区
      - 分配方式：簇，卷标
    - 4.索引文件*：构建逻辑块和物理块的索引表
      - 4.1单级索引分配：为每个文件分配一个索引块(表)，再把分配给该文件的所有盘块号都记录在该索引块中
      - 4.2多级索引分配：，如果所分配出去的盘块的盘块号已经装满一个索引块时，OS便为该文件建立另多级索引块
      - 4.3混合索引分配：直接地址+单级/多级索引分配方式
        - e.g. iaddr1-9：直接地址，10：一级，11：二级……
      - 优点：加快检索速度，既适应于顺序访问，也适应于随机访问|会花费较多外存时间；对于小文件采用索引分配方式时，其索引块的利用率将是极低的
    - 5.索引顺序文件为文件建立一张索引表，为每组记录中的第一个记录设置一个表项。
    - 6.直接文件和哈希文件(略)
### 4.3 目录管理
  - 文件目录：一种数据结构(文件名+文件逻辑结构+文件物理结构+存取控制信息+管理信息+文件类型…)，用于标识系统中的文件及其物理地址，供检索时使用
  - 目录管理要求：实现“按名存取”，提高对目录的检索速度，文件共享，允许文件重名
  - 文件控制块(PCB)：基本信息，存取控制信息，使用信息
  - 文件索引结点(i结点)：在检索目录文件的过程中，只用到了文件名(FCB=文件名+文件描述信息)。所以可以把文件描述信息单独形成新的数据结构，简称为i结点
    - 可以将目录项分为基本目录项(文件名+i结点指针)和符号目录项(i结点指针+物理地址+长度)
    - 磁盘索引节点：存放在磁盘上的索引结点，包括文件主标识符，类型，存取权限，物理地址[iaddr(1)~iaddr(12)]，长度，指针计数，存取时间
    - 内存索引结点：存放在内存中的索引结点，文件被打开时，要将磁盘索引结点拷贝到内存的索引结点中使用。增加了索引结点编号，状态，访问计数，链接指针
  - 目录结构
    - 1.单级目录结构：在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项中含文件名、文件扩展名、文件长度、文件类型、文件物理地址以及其它文件属性。
      - 缺点：查找速度慢，不允许重名，不便于实现文件共享
    - 2.多级目录结构：又称为树型目录结构，主目录在这里被称为根目录，把数据文件称为树叶，其它的目录均作为树的结点。从树的根(即主目录)开始，把全部目录文件名与数据文件名依次地用线连接起来
      - 绝对路径从根目录开始，相对路径从当前目录开始
      - 优点：查询速度更快，层次结构更清晰，容易赋予不同的存储权限，容易共享
      - 缺点：磁盘访问次数增加
      - 大多数操作系统如UNIX、Linux和Windows系列都采用了多级目录结构
    - 3.目录查询技术：利用文件名查询目录里文件的PCB或对应索引结点—>根据其中的文件物理地址(盘块号)，换算出文件在磁盘上的物理位置—>通过磁盘驱动程序，将所需文件读入内存
      - 查询方式
        - 线性检索(顺序检索)：利用用户提供的文件名，用顺序查找法从文件目录中找到目录项
        - Hash
### 4.4 文件存储空间的管理
  - 1.空闲表法：为每个文件分配一块连续的存储空间，建立空闲表
    - 是连续分配方式   表结构：序号|空闲盘块号|空闲盘块数
  - 2.空闲链表法：将所有空闲盘区拉成一条空闲链
    - 离散分配方式    表结构：表头|下一个盘块号
  - 3.位示图法*：利用二进制的一位来表示磁盘中一个盘块的使用情况，用m × n个位数来构成位示图
    - 盘块的分配：b = n(i - 1) + j  (n为每行位数，i为行，j为列)，同时修改位示图map[i,j]=1
    - 盘块的回收：i = (b - 1)DIV n + 1，j = (b - 1)MOD n + 1，修改位示图map=[i,j]=0
  - 4.成组链接法*：将每100个盘块作为一组，最末一组只有99个盘块，S.free(0)中则存放“0”，作为空闲盘块链的结束标志
### 4.5 文件共享
  - 1.共享索引结点：文件的物理地址及其它的文件属性等信息，不再是放在目录项中，而是放在索引结点中进行共享
  - 2.符号链接(软连接)：由系统创建一个LINK类型的新文件，类似于快捷方式。文件不包括实际的数据，只包括指向文件的路径
  - 3.硬链接：通过索引节点对文件的链接
  - Linux文件：文件类型|文件拥有者属性|文件所属用户属性|其他人对此文件的属性
    - 文件类型：普通文件-，目录文件d，符号链接文件l，字符设备文件c，块设备文件b，socket文件s，管道文件p
    - 文件属性：可读r，可写w，可执行x
    - ls -al：i结点号 文件属性 链接计数 文件拥有者 用户 文件大小 最近修改时间 文件名 
### 4.6 文件保护
  - 提升系统的可靠性
    - 1.备份技术：周期性转存，增量性转存
    - 2.磁盘容错技术：一/二/三级容错技术SFT(低级磁盘容错技术/中级磁盘容错技术/系统容错技术)
  - 提升系统的安全性
    - 1.访问控制矩阵：描述系统存取控制权限的矩阵，行为用户，列为资源对象，值为权限
    - 2.存取控制表：为文件设置存取控制属性，对访问控制矩阵按**列**划分构建控制表
    - 3.用户权限表：为用户设置权限，对访问控制矩阵按**行**划分构建控制表
    - 口令，密码
- 文件操作略
### 4.7 UNIX文件系统
  - 

---
## <center>第五章 存储管理器</center>
### 5.1 概述
### 5.2 分区存储管理
### 5.3 页式存储管理
### 5.4 段式存储管理

## <center>第六章 I/O设备管理</center>
### 6.1